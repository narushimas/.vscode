{
    "graph": {
        "prefix": "graph",
        "body": [
        "template< typename T = int >",
        "struct Edge {",
        "  int from, to;",
        "  T cost;",
        "  int idx;",
        "",
        "  Edge() = default;",
        "",
        "  Edge(int from, int to, T cost = 1, int idx = -1) : from(from), to(to), cost(cost), idx(idx) {}",
        "",
        "  operator int() const { return to; }",
        "};",
        "",
        "template< typename T = int >",
        "struct Graph {",
        "  vector< vector< Edge< T > > > g;",
        "  int es;",
        "",
        "  Graph() = default;",
        "",
        "  explicit Graph(int n) : g(n), es(0) {}",
        "",
        "  size_t size() const {",
        "    return g.size();",
        "  }",
        "",
        "  void add_directed_edge(int from, int to, T cost = 1) {",
        "    g[from].emplace_back(from, to, cost, es++);",
        "  }",
        "",
        "  void add_edge(int from, int to, T cost = 1) {",
        "    g[from].emplace_back(from, to, cost, es);",
        "    g[to].emplace_back(to, from, cost, es++);",
        "  }",
        "",
        "  void read(int M, int padding = -1, bool weighted = false, bool directed = false) {",
        "    for(int i = 0; i < M; i++) {",
        "      int a, b;",
        "      cin >> a >> b;",
        "      a += padding;",
        "      b += padding;",
        "      T c = T(1);",
        "      if(weighted) cin >> c;",
        "      if(directed) add_directed_edge(a, b, c);",
        "      else add_edge(a, b, c);",
        "    }",
        "  }",
        "};",
        "",
        "template< typename T = int >",
        "using Edges = vector< Edge< T > >;"
        ],
        "description": ""
    },

    "dijkstra": {
      "prefix": "dijkstra",
      "body": [
        "template< typename T >",
        "struct ShortestPath {",
        "  vector< T > dist;",
        "  vector< int > from, id;",
        "};",
        "",
        "template< typename T >",
        "ShortestPath< T > dijkstra(const Graph< T > &g, int s) {",
        "  const auto INF = numeric_limits< T >::max();",
        "  vector< T > dist(g.size(), INF);",
        "  vector< int > from(g.size(), -1), id(g.size(), -1);",
        "  using Pi = pair< T, int >;",
        "  priority_queue< Pi, vector< Pi >, greater<> > que;",
        "  dist[s] = 0;",
        "  que.emplace(dist[s], s);",
        "  while(!que.empty()) {",
        "    T cost;",
        "    int idx;",
        "    tie(cost, idx) = que.top();",
        "    que.pop();",
        "    if(dist[idx] < cost) continue;",
        "    for(auto &e : g.g[idx]) {",
        "      auto next_cost = cost + e.cost;",
        "      if(dist[e.to] <= next_cost) continue;",
        "      dist[e.to] = next_cost;",
        "      from[e.to] = idx;",
        "      id[e.to] = e.idx;",
        "      que.emplace(dist[e.to], e.to);",
        "    }",
        "  }",
        "  return {dist, from, id};",
        "}"
      ],
      "description": ""
    },

    "TreeDiameter": {
      "prefix": "TreeDiameter",
      "body": [
        "/**",
        " * @brief Tree-Diameter(木の直径)",
        " * @docs docs/tree-diameter.md",
        " */",
        "template< typename T = int >",
        "struct TreeDiameter : Graph< T > {",
        "public:",
        "  using Graph< T >::Graph;",
        "  using Graph< T >::g;",
        "  vector< Edge< T > > path;",
        "",
        "  T build() {",
        "    to.assign(g.size(), -1);",
        "    auto p = dfs(0, -1);",
        "    auto q = dfs(p.second, -1);",
        "",
        "    int now = p.second;",
        "    while(now != q.second) {",
        "      for(auto &e : g[now]) {",
        "        if(to[now] == e.to) {",
        "          path.emplace_back(e);",
        "        }",
        "      }",
        "      now = to[now];",
        "    }",
        "    return q.first;",
        "  }",
        "",
        "  explicit TreeDiameter(const Graph< T > &g) : Graph< T >(g) {}",
        "",
        "private:",
        "  vector< int > to;",
        "",
        "  pair< T, int > dfs(int idx, int par) {",
        "    pair< T, int > ret(0, idx);",
        "    for(auto &e : g[idx]) {",
        "      if(e.to == par) continue;",
        "      auto cost = dfs(e.to, idx);",
        "      cost.first += e.cost;",
        "      if(ret < cost) {",
        "        ret = cost;",
        "        to[idx] = e.to;",
        "      }",
        "    }",
        "    return ret;",
        "  }",
        "};",
        ""
      ],
      "description": ""
    }

}