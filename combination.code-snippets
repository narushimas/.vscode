{
    "combination": {
        "prefix": "combination",
        "body": [
          "template< typename T = mint >",
          "struct Combination {",
          "  vector< T > _fact, _rfact, _inv;",
          "",
          "  Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {",
          "    _fact[0] = _rfact[sz] = _inv[0] = 1;",
          "    for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;",
          "    _rfact[sz] /= _fact[sz];",
          "    for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);",
          "    for(int i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];",
          "  }",
          "",
          "  inline T fact(int k) const { return _fact[k]; }",
          "",
          "  inline T rfact(int k) const { return _rfact[k]; }",
          "",
          "  inline T inv(int k) const { return _inv[k]; }",
          "",
          "  T P(int n, int r) const {",
          "    if(r < 0 || n < r) return 0;",
          "    return fact(n) * rfact(n - r);",
          "  }",
          "",
          "  T C(int p, int q) const {",
          "    if(q < 0 || p < q) return 0;",
          "    return fact(p) * rfact(q) * rfact(p - q);",
          "  }",
          "",
          "  T H(int n, int r) const {",
          "    if(n < 0 || r < 0) return (0);",
          "    return r == 0 ? 1 : C(n + r - 1, r);",
          "  }",
          "};"
        ],
        "description": ""
      },

      "simple_combination": {
        "prefix": "simple_combination",
        "body": [
          "template< typename T >",
          "T cmb(T N, T K) {",
          "  if(K < 0 || N < K) return 0;",
          "  T ret = 1;",
          "  for(T i = 1; i <= K; ++i) {",
          "    ret *= N--;",
          "    ret /= i;",
          "  }",
          "  return ret;",
          "}"
        ],
        "description": ""
      },

      "pascal_table": {
        "prefix": "pascal_table",
        "body": [
          "template< typename T = mint >",
          "vector< vector< T > > pascal_table(int N) {",
          "  vector< vector< T > > mat(N + 1, vector< T >(N + 1));",
          "  for(int i = 0; i <= N; i++) {",
          "    for(int j = 0; j <= i; j++) {",
          "      if(j == 0 || j == i) mat[i][j] = 1;",
          "      else mat[i][j] = mat[i - 1][j - 1] + mat[i - 1][j];",
          "    }",
          "  }",
          "  return mat;",
          "}"
        ],
        "description": ""
      },

      "LucasCombination": {
        "prefix": "LucasCombination",
        "body": [
          "/* nCk % MOD (MODは10000以下程度の素数) を計算する構造体",
          "    構築: O(MOD^2)",
          "    クエリ: O(log N) ",
          "*/",
          "template < typename T = long long > ",
          "struct LucasCombination {",
          "    vector<vector<T>> com;  // 前計算の結果を保存",
          "    long long MOD;                    // MOD は素数である必要がある",
          "    LucasCombination(T _MOD) : MOD(_MOD) {",
          "        com.assign(MOD, vector<T>(MOD));",
          "        com[0][0] = 1;",
          "        for (int i = 1; i < MOD; i++) {",
          "            com[i][0] = 1;",
          "            for (int j = i; j > 0; j--) {",
          "                com[i][j] = (com[i - 1][j - 1] + com[i - 1][j]) % MOD;",
          "            }",
          "        }",
          "    }",
          "",
          "    T C(T n, T k) {",
          "        if(n < k) return 0;",
          "        T ret = 1;",
          "        while (n > 0) {  // 下から一桁ずつ計算する",
          "            int ni = n % MOD;",
          "            int ki = k % MOD;",
          "            ret *= com[ni][ki];",
          "            ret %= MOD;",
          "            n /= MOD;",
          "            k /= MOD;",
          "        }",
          "        return ret;",
          "    }",
          "};",
          ""
        ],
        "description": ""
      }

}